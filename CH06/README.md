# 第六章
- [x] 6.1  
    形参出现在函数定义;  
    实参是函数调用的实际值。
- [x] 6.2  
    (a) 改为：
    ```
    string f() {
        string s;
        // ...
        return s;
    ```
    }
    (b) 改为：`void f2(int i) { /* ... */ }`  
    (c) 改为：`int calc(int v1, int v2) { /* ... */ }`  
    (d) 改为：`double square (double x) { return x * x; }`  
- [x] 6.3  
- [x] 6.4  
- [x] 6.5  
- [x] 6.6  
    形参定义在函数形参列表里；局部变量定义在代码块里；局部静态变量定义在执行路径第一次经过定义语句，程序终止是才被销毁。  
- [x] 6.7  
- [x] 6.8  
- [x] 6.9  
    [g++编译](https://blog.csdn.net/dengshuai_super/article/details/51766786)
- [x] 6.10  
- [x] 6.11  
- [x] 6.12 
    引用好用。  
- [x] 6.13  
    前者是值传递，函数不会改变原来的实参； 
    后者是传引用参数，函数可以改变原来的实参。
- [x] 6.14  
- [x] 6.15  
    `const string &s`避免拷贝用引用，避免改`s`的内容用const；  
    `c`只需要`c`的值，用普通的值传参；  
    `string::size_type &occurs`传结果到外部用引用。  
    `s`是普通引用可能会改变`s`的值。  
    `occurs`如果是常量引用，不能改它的值，没法返回结果。  

- [x] 6.16  
    局限性在于常量字符串和字符串字面值无法作为该函数的实参，改为：
    ```cpp
    bool is_empty(const string &s) { return s.empty(); }
    ```
- [x] 6.17 
    第一个函数使用常量引用，第二个函数使用普通引用。  
- [ ] 6.18  
    (a) 
    ```cpp
    bool compare(const matrix &m1, const matrix &m2);
    ```
    (b) 
    ```cpp
    vector<int>::iterator change_val(int, vector<int>::iterator);
    ```
- [x] 6.19   
    (a) 不合法。`calc`只有一个参数。  
    (b) 合法  
    (c) 合法  
    (d) 合法  
- [x] 6.20  
    应该尽量将引用形参设为常量引用，除非有明确的目的是为了改变这个引用变量。如果形参应该是常量引用，而我们将其设为了普通引用，那么常量实参将无法作用于普通引用形参。  
- [x] 6.21  
    `const int *` 类型  
- [x] 6.22  
- [x] 6.23  
- [x] 6.24  
    数组做实参，被自动转换为指向首元素的指针。改为：
    ```cpp
    void print(const int (&ia)[10])
    {
        for (size_t i = 0; i != 10; ++i)
        cout << ia[i] << endl;
    }
    ```
- [ ] 6.25  
- [ ] 6.26  
- [ ] 6.27  
- [ ] 6.28
- [ ] 6.29
- [ ] 6.30
- [ ] 6.31
- [ ] 6.32
- [ ] 6.33
- [ ] 6.34
- [ ] 6.35
- [ ] 6.36
- [ ] 6.37
- [ ] 6.38
- [ ] 6.39
- [ ] 6.40
- [ ] 6.41
- [ ] 6.42
